#!/usr/bin/env python3
import argparse
import logging
import random
import fnmatch
from collections import Counter
from itertools import groupby, chain
import sys
import functools

from intervaltree import Interval, IntervalTree

logger = logging.getLogger(__name__)


def _fastq_parser(path):
    header = seq = ''

    with open(path) as f:
        for l in f:
            if l.startswith('>'):
                if seq:
                    yield header, seq.upper()
                    seq = ''
                header = l.lstrip('>').strip()
            else:
                seq += l.rstrip()

    if header:
        yield header, seq.upper()


class Chromosome:
    COUNT_N = str.maketrans("ATGC", 'Y' * 4)

    def __init__(self, seq, fraglen, ignore_n=True):
        self.seq = seq
        self.chromlen = self.len = len(seq)
        self.peak_regions = IntervalTree()
        self.blacklist = IntervalTree()
        self.fraglen = fraglen
        if ignore_n:
            pos = 0
            for k, g in groupby(self.seq.translate(self.COUNT_N)):
                l = sum(1 for _ in g)
                if k == 'N':
                    self.blacklist.add(Interval(pos, pos + l))
                    self.len -= l
                pos += l

    def choose_peak_regions(self, n):
        while len(self.peak_regions) < n:
            pos = random.randrange(self.chromlen - self.fraglen)
            peak = Interval(pos, pos + self.fraglen)
            if not self.blacklist.overlap(peak) and not self.peak_regions.overlap(peak):
                self.peak_regions.add(peak)

    def _get_read_from_fragment(self, frag, width, readlen):
        positive_strand = random.random() >= 0.5
        if positive_strand:
            pos = random.randrange(frag.begin, frag.begin + width)
        else:
            pos = random.randrange(frag.end - width, frag.end)
            pos -= readlen - 1

        return pos, positive_strand

    def get_reads_from_peaks(self, width, readlen, n):
        peaks = tuple(self.peak_regions)
        if peaks:
            for _ in range(n):
                peak = random.choice(peaks)
                yield self._get_read_from_fragment(peak, width, readlen)

    def get_reads_as_background(self, width, readlen, n):
        for _ in range(n):
            pos = random.randrange(0, self.chromlen - self.fraglen)
            fragment = Interval(pos, pos + self.fraglen)
            if not self.blacklist.overlap(fragment):
                yield self._get_read_from_fragment(fragment, width, readlen)


class Formatter:
    COMPLEMENT = str.maketrans("ATGC", "TACG")

    @staticmethod
    def _make_seq_name(chrname, pos, is_pos_strand, is_yield_from_peak):
        return "{}_{}_{}_{}".format(
            chrname,
            pos,
            '+' if is_pos_strand else '-',
            "peak" if is_yield_from_peak else "background"
        )

    @staticmethod
    def revcom(func):
        @functools.wraps(func)
        def _revcomp(self, chrname, pos, is_pos_strand, seq, is_yield_from_peak):
            if not is_pos_strand:
                seq = seq.translate(Formatter.COMPLEMENT)[::-1]
            return func(self, chrname, pos, is_pos_strand, seq, is_yield_from_peak)
        return _revcomp

    def format(self, *args, **kwargs):
        raise NotImplementedError


class FASTQFormatter(Formatter):
    @Formatter.revcom
    def format(self, chrname, pos, is_pos_strand, seq, is_yield_from_peak):
        print('@' + self._make_seq_name(chrname, pos, is_pos_strand, is_yield_from_peak),
              seq, '+', 'I' * len(seq), sep='\n')


class SAMFormatter(Formatter):
    MAPQ = 42

    def __init__(self, names, lengths):
        print("@HD", "VN:1.0", "SO:coordinate", sep='\t')
        for n, l in zip(names, lengths):
            print("@SQ", "SN:" + n, "LN:{}".format(l), sep='\t')
        print("@PG", "ID:Python{0}.{1}.{2}".format(*sys.version_info), "PN:" + __name__, "CL:" + ' '.join(sys.argv))

    def format(self, chrname, pos, is_pos_strand, seq, is_yield_from_peak):
        print(
            self._make_seq_name(chrname, pos, is_pos_strand, is_yield_from_peak),
            0 if is_pos_strand else 16,
            chrname,
            pos + 1,
            self.MAPQ,
            "{}M".format(len(seq)),
            '*',
            0,
            0,
            seq,
            'I' * len(seq),
            sep='\t'
        )


def _main():
    parser = argparse.ArgumentParser(
        description="Simulate ChIP-seq reads from a FASTA file with specified parameters. "
                    "Note that forward and reverse reads will be generated by fifty-fifty."
    )
    parser.add_argument("--seed", nargs='?',
                        help="If a seed value is geven, 'random.seed' will be called with this argument")
    parser.add_argument("-v", "--verbose", action="store_true", help="Output debug messages")

    inputarg = parser.add_argument_group(title="Input")
    inputarg.add_argument("fasta", nargs=1, help="Reference genome FASTA file")
    inputarg.add_argument("--ignore-n-bases", action="store_false",
                          help="Ignore substrings include N (Default: False)")
    inputarg.add_argument("-i", "--include-chr", nargs='+',
                          help="Spefify chromosomes to subsample targets")

    params = parser.add_argument_group(title="Main parameters")
    params.add_argument("-n", "--peaks", type=int, default=20000,
                        help="# of peaks (Default: 20000). ")
    params.add_argument("-w", "--width", type=int, default=100,
                        help="The width of enriched regions (Default: 100bp)")
    params.add_argument("-r", "--reads", type=int, default=10000000,
                        help="# of total reads to generate (Default: 10000000)")
    params.add_argument("-a", "--alpha", type=float, default=0.01,
                        help="S/N parameter (0 <= a <= 1, default: 0.01)")
    params.add_argument("-d", "--distance", type=int, default=200,
                        help="The distance between forward and reverse enriched regions (Default: 200bp)")
    params.add_argument("-l", "--readlen", type=int, default=50,
                        help="Sequence read length (Default: 50bp)")

    output = parser.add_argument_group(title="Output", description="Choose a output format (required)")
    outfmt = output.add_mutually_exclusive_group(required=True)
    outfmt.add_argument("-q", "--fastq", action="store_true",
                        help="Generate sequences as FASTQ format")
    outfmt.add_argument("-s", "--sam", action="store_true",
                        help="Generate sequences as SAM format")
    output.add_argument("--unsorted", action="store_true",
                        help="If this option specified, output reads will not be sorted "
                             "by the genomic coordinate (Default: False, output sorted reads)")

    args = parser.parse_args()
    fraglen = args.width * 2 + args.distance

    if args.seed:
        random.seed(args.seed)
    if args.verbose:
        logger.setLevel(logging.DEBUG)

    logger.info("Loading '{}'...".format(args.fasta[0]))
    chrnames = []
    chrlengths = []
    name2chr = {}
    for header, seq in _fastq_parser(args.fasta[0]):
        if args.include_chr and not any(fnmatch.fnmatch(header, pattern) for pattern in args.include_chr):
            continue
        chrnames.append(header)
        name2chr[header] = c = Chromosome(seq, fraglen, args.ignore_n_bases)
        chrlengths.append(c.chromlen)
        logger.debug("Load '{}', len = {:,}".format(header, c.chromlen))
    if not name2chr:
        logger.critical("Input seems empty.")
        exit(1)

    #
    genomelen = sum(c.chromlen for c in name2chr.values())
    if fraglen * args.peaks > genomelen / 2:
        logger.critical("Error: Too many peak regions. Each peak must be the their width apart.")
        sys.exit(1)
    logger.info("Choose peak numbers for each chromosome...")
    peak_sizes = Counter(random.choices(chrnames, weights=chrlengths, k=args.peaks))
    logger.debug("generate peaks: {}".format(peak_sizes))
    logger.info("Choose peak regions...")
    for name in chrnames:
        logger.debug(name + "...")
        name2chr[name].choose_peak_regions(peak_sizes[name])

    #
    if args.fastq:
        logger.debug("Generate as FASTQ")
        formatter = FASTQFormatter()
    elif args.sam:
        logger.debug("Generate as SAM")
        formatter = SAMFormatter(chrnames, chrlengths)
    else:
        raise AssertionError

    #
    logger.info("Choose read numbers for each chromosome...")
    sample_sizes = Counter(random.choices(chrnames, weights=chrlengths, k=args.reads))
    logger.info("generate reads: {}".format(sample_sizes))
    logger.info("Generating reads...")
    for name in chrnames:
        logger.debug(name + "...")
        chrom = name2chr[name]
        reads_in_peaks = int(sample_sizes[name] * args.alpha)
        reads_in_bg = sample_sizes[name] - reads_in_peaks
        reads = chain(
            ((pos, strand, False) for pos, strand in chrom.get_reads_as_background(args.width, args.readlen, reads_in_bg)),
            ((pos, strand, True) for pos, strand in chrom.get_reads_from_peaks(args.width, args.readlen, reads_in_peaks))
        )
        if not args.unsorted:
            logger.debug("Sorting...")
            reads = sorted(reads, key=lambda x: x[0])
        logger.debug("Printing...")
        for pos, is_pos_strand, is_yield_from_peak in reads:
            seq = chrom.seq[pos:(pos + args.readlen)]
            formatter.format(name, pos, is_pos_strand, seq, is_yield_from_peak)


if __name__ == "__main__":
    logger.addHandler(logging.StreamHandler())
    logger.setLevel(logging.INFO)
    _main()
    logger.debug("Complete!")
